INCLUDE PMACROS.ASM

.MODEL	SMALL
.STACK 64
.DATA

;MAX NUMBER OF OBSTACLES IN GAME IS 15 OBSTACLE
;OBSTACLES BUFFER
;OBS_COUNT IS ACTUAL NUMBER OS OBSTACLE
;OBST ARRAY IS FORMATED AS 15*(TYPE,ROW,COL,UP/DOWN)
OBS_COUNT	DB  0	
OBS_ARR		DB	60 DUP (0)

;LIMITS OF EACH REGION FOR BH
OUTER_N		EQU		80
OUTER_W		EQU     60
OUTER_E		EQU		180
OUTER_S		EQU		240

MID_N		EQU		110
MID_W		EQU		80
MID_E		EQU		160
MID_S		EQU		210

INNER_N		EQU		140
INNER_W		EQU		100
INNER_E		EQU		140
INNER_S		EQU		180

;ADDED POSITIONS FOR EACH REGION OF BH
REG1_X		EQU		13
REG1_Y		EQU		12

REG2_X		EQU		26
REG2_Y		EQU		24

REG3_X		EQU		52
REG3_Y		EQU		48


;PLAYERS POSITIONS 
SHIP1Y		DW 	296
SHIP1X		DW 	199
	
	
SHIP2X		DW 	24
SHIP2Y		DW	0

SHIPSIZE_R	EQU	26
SHIPSIZE_C	EQU	24

LIVES1		DB  3
LIVES2		DB  3

TIMESTEP 	DB  1
COL		 	DW  ?
OBST 	 	DB  ?
RANDOMVAR 	DB  ? 
.CODE

;GENERATES RANDOM X,Y,OBSTACLE ACCORDING TO CURRENT TIMESTEP FROM EQN : 4*(X^2+4)/3 MOD SELECTED ITEM
GENERATEOBSTACLE PROC

			;CHECKING MAX COUNT
			lEA BX,OBS_COUNT
			MOV DX,[BX]
			CMP DX,15
			JE OEND
			
			;GETTING RANDOM VAR
			MOV AL,TIMESTEP
			MOV AH,0
			MUL AL
			ADD AX,4
			MOV BX,4
			XCHG AX,BX
			MUL BX
			
			MOV AH,0						 ;IGNORE AH TO AVOIDE OVERFLOW
			MOV BL,3
			DIV BL
			MOV RANDOMVAR,AL
			
			lEA BX,OBS_COUNT
			
			;GETTING OBSTACLE TYPE (GAME HAS 3 OSBTACLE TYPES)
			;0 1ST , 1 2ND , 2 3RD
			;AL HAS RANDOM VARIABLE 
			INC byte ptr [BX]	;INCREMENTING OBSTACLES COUNT
			
			;FINDING FIRST EMPTY PLACE
			INC BX
FINDPLACE:	CMP byte ptr [BX],0
			JE EMPTYPLACE
			;ELSE ADD 4 TO CHECK NEXT PLACE
			ADD BX,4
			JMP FINDPLACE
			
EMPTYPLACE:	MOV AH, 0
			MOV CL,3
			DIV CL
			
			CMP AH,0
			JNE OBS2
			MOV byte ptr [BX],'@'
			JMP GETOBSROW
			
OBS2:		CMP AH,1
			JNE	OBS3
			MOV byte ptr [BX],233
			JMP GETOBSROW
			
OBS3:		MOV byte ptr [BX],0FEH
			
			
			
			;GETTING ROW
GETOBSROW:	INC BX
			MOV AL,RANDOMVAR  
			MOV AH,0
			MOV CH,0
			MOV CL,2
			DIV CL	;AH CONTAINS REM
			 
			CMP AH,0
			JNE SOUTH
			MOV byte ptr [BX],0
			MOV byte ptr [BX]+2,0
			JMP GETOBSCOL
			
SOUTH:		MOV byte ptr[BX],24
			MOV byte ptr[BX]+2,1
			
			
			;GETTING COLUMN
GETOBSCOL:	INC BX
            MOV AL,RANDOMVAR 
            MOV AH,0
			MOV CL,80
			DIV CL
			MOV [BX],AH
			 
OEND:     RET

GENERATEOBSTACLE ENDP  


;_____________________________________________________________
;DRAWOSBTACLES PROC
DRAWOSBTACLES PROC	
			PUSH CX
			
			MOV CX,15
			MOV BX,OFFSET OBS_ARR

DRAWLOOP:	MOV DL,[BX]
			CMP DL,0
			JE NEXT
			SCURSOR	[BX]+1,[BX]+2
			PRINTCHAR [BX],04
			
NEXT:		ADD BX,4
			LOOP DRAWLOOP    
			POP CX

			RET
DRAWOSBTACLES ENDP


;_____________________________________________________________
; MOVEOBSTACLESS OBSTACLE	 AND REMOVEOBSTACLESS THE PREVIOUS ONE
MOVEOBSTACLES PROC
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		
		MOV SI,OFFSET OBS_ARR
		
		MOV CX,15
OLOOP:	CMP BYTE PTR [SI],0     			;CHECK IS OFBSTACLE EXISTS OR NOT
        JE RE
        CMP BYTE PTR [SI+3],0
		JNZ UPWARDS
		
DOWNWARS:CMP BYTE PTR[SI+1],18H				;CHECKS IF OBSTACLE REACHED END OF SCREEN AND THEN DELETES IT
		JNE	MOVEOBSTACLESDN
		MOV BYTE PTR [SI],0
		JMP RE
	
MOVEOBSTACLESDN:	INC BYTE PTR [SI+1]		;INCREMENT ROW OTHERWISE
		JMP RE
	
UPWARDS:CMP BYTE PTR[SI+1],00				;CHECKS IF OBSTACLE REACHES BEGINING OF SCREEN AND THEN DELETES IT
		JNE	MOVEOBSTACLESUP
		MOV BYTE PTR [SI],0
		JMP RE
MOVEOBSTACLESUP:	DEC BYTE PTR [SI+1]		;DECREMENT ROW OTHERWISE

RE:		ADD SI, 4
		LOOP OLOOP

		
		POP DX
		POP CX
		POP BX
		POP AX
		RET
MOVEOBSTACLES	ENDP
;_______________________________________________
;BLACKHOLE BEHAVIOR -- BX CONTAINS OFFSET PLAYER_X -- SI CONTAINS OFFSET PLAYER_Y					
BLACKHOLE   PROC
			
			PUSH AX
			PUSH CX
			PUSH DX
			
			;CHECKING OUTER REGION
			CMP BYTE PTR[BX], OUTER_N
			JB  EXT
			CMP BYTE PTR[BX], OUTER_S		;CHECKEAST1
			JA  EXT
			CMP BYTE PTR[SI], OUTER_W
			JB  EXT
			CMP BYTE PTR[SI], OUTER_E
			JA  EXT
			
			;CHECKING THE X-AXIS
			CMP BYTE PTR[BX], MID_N
			JA  REG1
			CMP BYTE PTR[BX], INNER_N
			JA  REG2
			CMP BYTE PTR[BX], INNER_S
			JA  REG3
			CMP BYTE PTR[BX], MID_S
			JA  REG2
			CMP BYTE PTR[BX], OUTER_S
			JA  REG1
			                                
			;CHECKING THE Y-AXIS
			CMP BYTE PTR[SI], MID_W
			JB  REG1
			CMP BYTE PTR[SI], INNER_W		;CHECKSOUTH1
			JB  REG2
			CMP BYTE PTR[SI], INNER_E
			JB  REG3
			CMP BYTE PTR[SI], MID_E
			JB REG2
			CMP BYTE PTR[SI], OUTER_E
			JB REG1
			
			
REG1:		ADD TIMESTEP, 1
			ADD BYTE PTR[BX], REG1_X 
			ADD BYTE PTR[SI], REG1_Y
			JMP EXT
			
REG2:		ADD TIMESTEP, 2
			ADD BYTE PTR[BX], REG2_X
			ADD BYTE PTR[SI], REG2_Y
			JMP EXT
			
REG3:       ADD TIMESTEP, 3
			ADD BYTE PTR[BX], REG3_X
			ADD BYTE PTR[SI], REG3_Y
			
EXT:		POP DX
			POP CX
			POP AX
			RET
BLACKHOLE   ENDP
;_____________________________________________________________

MAIN PROC FAR
			MOV AX,@DATA
			MOV DS,AX
			
			;SWITCH VIDEO MODE
			MOV AH,0
			MOV AL,13H
			INT 10H
			
			MOV CX,100
INFLOOP:   
		   CALL GENERATEOBSTACLE
		   CALL DRAWOSBTACLES
		   CALL MOVEOBSTACLES
			
			ADD TIMESTEP, 1
			DEL
			CLEARSCREEN
			
			;CHECK IF ESCAPE IS PRESSED
			MOV AH,01
			INT 16H
			JZ LP1	;NOTHING IS PRESSED
			CMP AH,01
			JE EXIT
LP1:		LOOP INFLOOP
			
EXIT:		MOV AH,4CH
			INT 21h
			
MAIN ENDP
END MAIN
